var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-Documentation","page":"Function Documentation","title":"Function Documentation","text":"","category":"section"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"CurrentModule = NeuralDynamics\nDocTestSetup = quote\n    using NeuralDynamics\nend","category":"page"},{"location":"functions/#Model-Building","page":"Function Documentation","title":"Model Building","text":"","category":"section"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"initializeParams","category":"page"},{"location":"functions/#NeuralDynamics.initializeParams","page":"Function Documentation","title":"NeuralDynamics.initializeParams","text":"initializeParams(model::String; args...)\n\nCreates a dictionary of parameters for a defined model. In the absence of optional arguments the model will be initialized with default parameter values. If some optional arguments are passed they will replace those default values in the dictionary. Currently implemented models include:\n\n\"FHN\": FitzHugh-Nagumo\n\"SFF\": Simple Feed-forward\n\"WC\": Wilson-Cowan\n\nExamples\n\njulia> params = initializeParams(\"FHN\")\nDict{Symbol, Float64} with 7 entries:\n :R     => 1\n :tau1  => 1.0\n :tau2  => 2.0\n :I     => 0\n :b1    => 1.1\n :b0    => 0.9\n\t\njulia> params = initializeParams(\"FHN\", tau1 = 5.0, b1 = 2.0)\nDict{Symbol, Float64} with 7 entries:\n :R     => 1\n :tau1  => 5.0\n :tau2  => 2.0\n :I     => 0\n :b1    => 2.0\n :b0    => 0.9\n\nNote\n\nCheck the documentation for a given model in the docs to see what parameters  are required.\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"modelEquations","category":"page"},{"location":"functions/#NeuralDynamics.modelEquations","page":"Function Documentation","title":"NeuralDynamics.modelEquations","text":"modelEquations(name::String)\nmodelEquations(name::String, DEs, nullclines)\n\nGenerates a struct of type modelEquations containing the model name, differential equations, and nullcline equations. Custom models can be built by inputting your own equations. Some models are automatically implemented and the relevant struct will be returned just by calling these models by name. Currently implemented models include:\n\n\"FHN\": FitzHugh-Nagumo\n\"WC\": Wilson-Cowan\n\nExamples\n\njulia> mdl=modelEquations(\"FHN\")\nmodelEquations(\"FHN\", (NeuralDynamics.fhn_dudt, NeuralDynamics.fhn_dwdt), (NeuralDynamics.fhn_nullclinewu, NeuralDynamics.fhn_nullclineww))\n\t\njulia> mdl=modelEquations(\"WC\")\nmodelEquations(\"WC\", (NeuralDynamics.wc_drₑ, NeuralDynamics.wc_drᵢ), (NeuralDynamics.wc_eNullcline, NeuralDynamics.wc_iNullcline))\n\n\n\n\n\n","category":"type"},{"location":"functions/#Phase-Analysis","page":"Function Documentation","title":"Phase Analysis","text":"","category":"section"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"getNullclines","category":"page"},{"location":"functions/#NeuralDynamics.getNullclines","page":"Function Documentation","title":"NeuralDynamics.getNullclines","text":"getNullclines(x, modelEqs, params::Dict)\n\ngetNullclines(x, y, modelEqs, params::Dict)\n\nDetermines the nullclines of the defined model over the sampled space using the  dictionary of model parameters and struct containing the model equations. \n\nThe nullcine of x with respect to some parameter t is defined as the  points along the phase plane were fracdxdt = 0.\n\nExample\n\njulia> params = initializeParams(\"FHN\")\nDict{Symbol, Float64} with 7 entries:\n :R     => 1\n :tau1  => 1.0\n :tau2  => 2.0\n :I     => 0\n :b1    => 1.1\n :b0    => 0.9\n\njulia> mdl = modelEquations(\"FHN\")\n modelEquations(\"FHN\", (NeuralDynamics.fhn_dudt, NeuralDynamics.fhn_dwdt), (NeuralDynamics.fhn_nullclinewu, NeuralDynamics.fhn_nullclineww))\n\njulia> ncls = getNullclines(-2.5:0.01:2.5, mdl, params)\n\njulia> params = initializeParams(\"WC\")\nDict{Symbol, Float64} with 12 entries:\n  :tauE   => 1.0\n  :wEE    => 9.0\n  :wIE    => 13.0\n  :thetaE => 2.8\n  :wEI    => 4.0\n  :wII    => 11.0\n  :tauI   => 2.0\n  :aE     => 1.2\n  :aI     => 1.0\n  :II     => 0.0\n  :thetaI => 4.0\n  :IE     => 0.0\n\njulia> mdl = modelEquations(\"WC\")\n modelEquations(\"WC\", (NeuralDynamics.wc_drₑ, NeuralDynamics.wc_drᵢ), (NeuralDynamics.wc_eNullcline, NeuralDynamics.wc_iNullcline))\n\njulia> ncls = getNullclines((-0.01:0.001:0.96, -0.01:0.001:0.8), mdl, params)\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"getVectorFields","category":"page"},{"location":"functions/#NeuralDynamics.getVectorFields","page":"Function Documentation","title":"NeuralDynamics.getVectorFields","text":"getVectorFields(x, modelEqs ,params::Dict; subdivisions::Int64=10)\n\nGiven an array of x-indices (and optionally y-indices), a model, and a  dictionary of model parameters a Vector of 2D arrays will be returned with the  local x and y gradients at evenly sampled points across the defined space. The  granularity of sampling is determined by the optional parameter subdivisions  with a default sampling density of 10 resulting in a 10x10 grid of vector  fields.\n\nExamples\n\njulia> params = initializeModel(\"FHN\")\nDict{Symbol, Float64} with 7 entries:\n :R     => 1\n :tau1  => 1.0\n :tau2  => 2.0\n :I     => 0\n :b1    => 1.1\n :b0    => 0.9\n\njulia> mdl = modelEquations(\"FHN\")\n modelEquations(\"FHN\", (NeuralDynamics.fhn_dudt, NeuralDynamics.fhn_dwdt), (NeuralDynamics.fhn_nullclinewu, NeuralDynamics.fhn_nullclineww))\n\njulia> fields = getVectorFields(-2.5:0.01:2.5, mdl)\n\t\njulia> fields = getVectorFields(-2.5:0.01:2.5, mdl, subdivisions=5)\n\njulia> fields = getVectorFields(-2.5:0.01:2.5, -1:0.01:1, mdl, subdivisions=20)\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"findFixedPoints","category":"page"},{"location":"functions/#NeuralDynamics.findFixedPoints","page":"Function Documentation","title":"NeuralDynamics.findFixedPoints","text":"findFixedPoints(xGuess::Vector, func, params)\n\nGiven an array xGuess giving initial guesses for fixed points, a helper function (see below) func to find the roots of, and a dictionary of model parameters,  params this function will return a vector of fixed points determined using Newton's method. Helper functions have been defined for the \"FHN\" and \"WC\" models and follow the general convention fFHN! or fWC! respectively. \n\nExamples\n\njulia> params = initializeParams(\"WC\")\nDict{Symbol, Float64} with 12 entries:\n  :tauE   => 1.0\n  :wEE    => 9.0\n  :wIE    => 13.0\n  :thetaE => 2.8\n  :wEI    => 4.0\n  :wII    => 11.0\n  :tauI   => 2.0\n  :aE     => 1.2\n  :aI     => 1.0\n  :II     => 0.0\n  :thetaI => 4.0\n  :IE     => 0.0\n\njulia> guesses = [[0.0,0.0],[0.4,0.2],[0.9,0.6]]\n3-element Vector{Vector{Float64}}:\n [0.0, 0.0]\n [0.4, 0.2]\n [0.9, 0.6]\n\n\njulia> fps = findFixedPoints(guesses, fWC!, params)\n3-element Vector{Vector{Float64}}:\n [0.0, 0.0]\n [0.33685240829408575, 0.168419676112977]\n [0.9384304716775121, 0.6724810433274886]\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"getJacobianEigenvalues","category":"page"},{"location":"functions/#NeuralDynamics.getJacobianEigenvalues","page":"Function Documentation","title":"NeuralDynamics.getJacobianEigenvalues","text":"getJacobianEigenvalues(fixedPoints, params)\n\nGiven an array of fixed points and model parameters this function will return the eigenvalues of the Jacobian matrix for the Wilson-Cowan model. Currently, only the Wilson- Cowan model equations have been implemented.\n\nJ = beginbmatrix fracpartialpartial r_EG_E(r_E^* r_I^*)  fracpartialpartial r_IG_E(r_E^* r_I^*)  fracpartialpartial r_EG_I(r_E^* r_I^*)  fracpartialpartial r_IG_I(r_E^* r_I^*) endbmatrix\n\nExamples\n\njulia> params = initializeParams(\"WC\")\nDict{Symbol, Float64} with 12 entries:\n  :tauE   => 1.0\n  :wEE    => 9.0\n  :wIE    => 13.0\n  :thetaE => 2.8\n  :wEI    => 4.0\n  :wII    => 11.0\n  :tauI   => 2.0\n  :aE     => 1.2\n  :aI     => 1.0\n  :II     => 0.0\n  :thetaI => 4.0\n  :IE     => 0.0\n\njulia> guesses = [[0.0,0.0],[0.4,0.2],[0.9,0.6]]\n3-element Vector{Vector{Float64}}:\n [0.0, 0.0]\n [0.4, 0.2]\n [0.9, 0.6]\n\n\njulia> fps = findFixedPoints(guesses, fWC!, params)\n3-element Vector{Vector{Float64}}:\n [0.0, 0.0]\n [0.33685240829408575, 0.168419676112977]\n [0.9384304716775121, 0.6724810433274886]\n\n julia> eigenVals = getJacobianEigenvalues(fps, params)\n 3-element Vector{Any}:\n  ComplexF64[-0.6233838572258439 - 0.1311095729053099im, -0.6233838572258439 + 0.1311095729053099im]\n  [-0.8726689790568727, 1.057207976436168]\n  [-1.4219741349895596, -0.95956219494619]\n \n\n\n\n\n\n","category":"function"},{"location":"functions/#Convenience-Functions","page":"Function Documentation","title":"Convenience Functions","text":"","category":"section"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"sigmoid","category":"page"},{"location":"functions/#NeuralDynamics.sigmoid","page":"Function Documentation","title":"NeuralDynamics.sigmoid","text":"sigmoid(x, a, θ)\n\nThe sigmoid activation function with input x, gain parameter a, and threshold  parameter θ.\n\nExamples\n\njldoctest julia> s = sigmoid(0.1:0.1:10, 1, 3) 100-element Vector{Float64}:  0.0047276899008509565  0.009898302721301974  ⋮  0.9515673560023477  0.9516630756280327\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"invSigmoid","category":"page"},{"location":"functions/#NeuralDynamics.invSigmoid","page":"Function Documentation","title":"NeuralDynamics.invSigmoid","text":"invSigmoid(x, a, θ)\n\nThe inverse sigmoid function with input x, gain parameter a, and threshold  parameter θ.\n\nExamples\n\n```jldoctest julia> invSigmoid(0.4, 1, 3)  2.788923286876553\n\njulia> invSigmoid.(0.1:0.1:0.9, 1, 3) 9-element Vector{Float64}:  1.2450653370666414  1.8876115356593868  2.369626590583188  2.788923286876553  3.190275495162158  3.6077434164384417  4.084930356824196  4.71455281467788  5.891524586559516  ```\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"dSigmoid","category":"page"},{"location":"functions/#NeuralDynamics.dSigmoid","page":"Function Documentation","title":"NeuralDynamics.dSigmoid","text":"dSigmoid(x, a, θ)\n\nThe derivative of the sigmoid function with input x, gain parameter a, and  threshold parameter θ.\n\nExamples\n\n```jldoctest julia> dSigmoid(0.4, 1, 3)  0.0643582991757735\n\njulia> dSigmoid.(0.1:0.1:0.9, 1, 3)  9-element Vector{Float64}:   0.04943356893664324   0.05403811475638431   0.05900771248391522   0.0643582991757735   0.07010371654510816   0.07625499905185225   0.08281956699074117   0.08980032904006871   0.0971947048006254  ```\n\n\n\n\n\n","category":"function"},{"location":"functions/#Simulation","page":"Function Documentation","title":"Simulation","text":"","category":"section"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"simulate","category":"page"},{"location":"functions/#NeuralDynamics.simulate","page":"Function Documentation","title":"NeuralDynamics.simulate","text":"simulate(t, model::String, params::Dict, init)\n\nGiven a timecourse of t passed as a Vector or StepRange this function will simulate the model defined by model (String) with parameters params (Dict) with initial conditions defined in the init (Vector or Float).  The results are returned as a Vector. Currently implemented models are:\n\n\"FHN\": FitzHugh-Nagumo\n\"SFF\": Simple Feed-forward\n\"WC\": Wilson-Cowan\n\nExamples\n\njulia> mdl = initializeModel(\"FHN\")\nDict{Symbol, Float64} with 7 entries:\n :R     => 1\n :tau1  => 1.0\n :tau2  => 2.0\n :I     => 0\n :b1    => 1.1\n :b0    => 0.9\n\t\njulia> ru, rw = simulate(0:0.1:50, \"FHN\", mdl, (-2.0, 1.0))\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#Plotting","page":"Function Documentation","title":"Plotting","text":"","category":"section"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"plotVectorFields!","category":"page"},{"location":"functions/#NeuralDynamics.plotVectorFields!","page":"Function Documentation","title":"NeuralDynamics.plotVectorFields!","text":"plotVectorFields!(x, fields::Tuple; arrowScale=0.2, kwargs...)\n\nConvenient plotting function to add vector fields to an existing phase plot. It  takes a single vector x as input (for symmetrical axes) or two vectors x and  y for unique axis ranges. The fields should be passed as a vector of 2D arrays  giving the x and y gradients respectively. \n\nThe arrowScale defaults to 0.2 but can be passed as an optional argument.  Additional plotting arguments can also be passed as kwargs....\n\nCheck Plots.jl for additional information on plot arguments.\n\nExamples\n\njulia> plotVectorFields!(-1:0.1:1, ([3 2 3; 2 1 2; 3 2 3], [3 2 3; 2 1 2; 3 2 3]))\n\njulia> plotVectorFields!(-1:0.1:1, ([3 2 3; 2 1 2; 3 2 3], [3 2 3; 2 1 2; 3 2 3]), arrowSize = 0.5)\n\njulia> plotVectorFields!(-1:0.1:1, ([3 2 3; 2 1 2; 3 2 3], [3 2 3; 2 1 2; 3 2 3]), color=\"red\", alpha=0.3)\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"plotTrajectory!","category":"page"},{"location":"functions/#NeuralDynamics.plotTrajectory!","page":"Function Documentation","title":"NeuralDynamics.plotTrajectory!","text":"plotTrajectory!(x, y; kwargs...)\n\nConvenient plotting function to add results of a simulation to an existing phase  plot. It takes the simulation output along the abscissa and ordinate as arguments  in the form of  two Vectors or StepRanges x and y.\n\nAdditional plotting arguments can also be passed as kwargs....\n\nCheck Plots.jl for additional information on plot arguments.\n\nExamples\n\njulia> plotTrajectory!(-1:0.1:1, -1:0.1:1)\n\njulia> plotTrajectory!(-1:0.1:1, -1:0.1:1, color=red, label=\"simulation\", xlab=\"x\", ylab=\"y\")\n\nFor similar functionality see plotTrajectories!\n\n\n\n\n\n","category":"function"},{"location":"functions/","page":"Function Documentation","title":"Function Documentation","text":"plotTrajectories!","category":"page"},{"location":"functions/#NeuralDynamics.plotTrajectories!","page":"Function Documentation","title":"NeuralDynamics.plotTrajectories!","text":"plotTrajectories!(t, x, y, model::String, params::Dict; kwargs...)\n\nConvenient plotting function to add results of multiple simulations to an  existing phase plot. It takes the simulation timecourse t (Vector or StepRange),   and x and  y Vectors or StepRanges defining the sampling in each direction in phase space respectively. The model is defined as a String and the model parameters param as a Dict. Currently implemented models are:\n\n\"FHN\": FitzHughNagumo\n\nAdditional plotting arguments can also be passed as kwargs....\n\nCheck Plots.jl for additional information on plot arguments.\n\nExamples\n\njulia> mdl = initializeModel(\"FHN\")\nDict{Symbol, Float64} with 7 entries:\n :R     => 1\n :tau1  => 1.0\n :tau2  => 2.0\n :I     => 0\n :b1    => 1.1\n :b0    => 0.9\n\njulia> plotTrajectories!(0:0.1:50, -2.5:1:2.5, -2.5:1:2.5, \"FHN\", mdl)\n\njulia> plotTrajectories!(0:0.1:50, -2.5:1:2.5, -2.5:1:2.5, \"FHN\", mdl, color=:gray, label=\"simulations\")\n\nFor similar functionality see plotTrajectory!\n\n\n\n\n\n","category":"function"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"CurrentModule = NeuralDynamics\nDocTestSetup = quote\n    using NeuralDynamics\nend","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Below I provide a basic introduction to implementations of the models in this package. ","category":"page"},{"location":"models/#FitzHugh-Nagumo","page":"Models","title":"FitzHugh-Nagumo","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"","category":"page"},{"location":"models/#Description","page":"Models","title":"Description","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The FitzHugh-Nagumo model is a 2D approximation of the Hodgkin-Huxley model. The general form of the dynamical equations describing this model are","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"tau dotu = F(uw) + RI","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"tau_w dotw = G(uw)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"where u is the membrane voltage, I is the input current, and R is the resistance. The three gating variables of the Hodgkin-Huxley model are summarized by the single recovery variable w. F(uw) and G(uw) are given by the following equations:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"F(uw) = u - frac13u^3-w","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"G(uw) = b_0+b_1u-w","category":"page"},{"location":"models/#Parameters","page":"Models","title":"Parameters","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"tau1: Time constant governing equation 1\ntau2: Time constant governing equation 2\nb0: Parameter for equation 2\nb1: Parameter for equation 2\nR: Resistance\nI: Input current","category":"page"},{"location":"models/#Building-the-model","page":"Models","title":"Building the model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"## Default parameters\nparams = initializeParams(\"FHN\")\n\n## Change some parameters\ninitializeParams(\"FHN\", tau1=1.2, b0=0.5)\n\n## Customize all parameters\ninitializeParams(\"FHN\", tau1=1.2, tau2=2.5, b0=1.1, b1=1.9, R=1.2, I=1)","category":"page"},{"location":"models/#Simple-Feed-forward","page":"Models","title":"Simple Feed-forward","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"","category":"page"},{"location":"models/#Description-2","page":"Models","title":"Description","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"A simple feed-forward network can be described by the following dynamical equation describing network connections between excitatory neurons:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"fracdr_Edt = -r_E+F(wcdot r_E+I_ext)τ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Here, r_E describes the network activity, w decribes the weight of the connectivity between neurons, I_ext is the external input to the network, and tau is the time constant for the decay of network activity. The average neuronal activity is described by a sigmoid function F(r_E) of the following form:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"F(xatheta)=frac11+e^-a(x-theta)-frac11+e^atheta","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Here, a describes the gain of the function and theta the threshold.","category":"page"},{"location":"models/#Parameters-2","page":"Models","title":"Parameters","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"tau: Time constant governing network dynamics\na: gain\ntheta: threshold\nw: connection weight\nI: Input current","category":"page"},{"location":"models/#Building-the-model-2","page":"Models","title":"Building the model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"## Default parameters\nparams = initializeParams(\"SFF\")\n\n## Change some parameters\ninitializeParams(\"SFF\", tau1=1.2, a=0.5)\n\n## Customize all parameters\ninitializeParams(\"SFF\", tau=1, a=0.5, theta=1.1, w=1, I=1)","category":"page"},{"location":"models/#Wilson-Cowan","page":"Models","title":"Wilson-Cowan","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"","category":"page"},{"location":"models/#Description-3","page":"Models","title":"Description","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The Wilson-Cowan network describes a network of neurons with distinct excitatory and inhibitory populations that project onto each other and within themselves. The network can be described by the following coupled differential equations:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"tau_E fracdr_Edt=-r_E+F_E(w_EEr_E-w_EIr_I+I^ext_E a_E theta_E)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"tau_I fracdr_Idt=-r_I+F_I(w_IEr_E-w_IIr_I+I^ext_I a_I theta_I)","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"Here, r_E(t) represents the average firing rate of the excitatory population at time t, r_I(t) represents the average firing rate of the inhibitory population at time t, The connection strengths are represented by the four weight terms as follows: w_EE (E rightarrow E), w_EI (I rightarrow E), w_IE (E rightarrow I), and w_II (I rightarrow I). The transfer functions for each population can be represented by distinct sigmoids of the following form: ","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"F(xatheta)=frac11+e^-a(x-theta)-frac11+e^atheta","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"This implementation of the model is temporally coarse grained and assumes no absolute refractory period.","category":"page"},{"location":"models/#Parameters-3","page":"Models","title":"Parameters","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"tauE: Time constant governing the excitatory network dynamics\naE: gain term for the excitatory transfer function\nthetaE: threshold term for the excitatory transfer function\ntauI: Time constant governing the inhibitory network dynamics\naI: gain term for the inhibitory transfer function\nthetaI: threshold term for the inhibitory transfer function\nwEE: connection strength within the excitatory network\nwEI: connection strength from the inhibitory to the excitatory network\nwIE: connection strength from the excitatory to the inhibitory network\nwII: connection strength within the inhibitory network\nIE: external input to the excitatory network\nII: external input to the inhibitory network","category":"page"},{"location":"models/#Building-the-model-3","page":"Models","title":"Building the model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"## Default parameters\nparams = initializeParams(\"WC\")\n\n## Change some parameters\ninitializeParams(\"WC\", tauE=1.2, aE=0.5)\n\n## Customize all parameters\ninitializeParams(\"WC\"; tauE= 1.2, tauI= 2.5, aE=0.5, thetaE=0.8, aI=1.1, thetaI=1.2, wEE=6.4, wEI=4.8, wIE=6.0, wII=1.2, IE=0.8, II=0.2)","category":"page"},{"location":"#NeuralDynamics.jl","page":"Home","title":"NeuralDynamics.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = NeuralDynamics\nDocTestSetup = quote\n    using NeuralDynamics\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"NeuralDynamics is a package for basic analysis, simulation, and visualization of dynamical models for neurons or networks of neurons. It is based largely on a  minicourse taught by @nalewkoz on Neural Bifurcations. The Pluto notebooks can  serve as interactive tools to visualize some of the models implemented.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Implementations of some basic neuron and network models.\nConvenience functions for phase analysis and simulation.\nConvenient plotting functions built on Plots.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest release of NeuralDynamics can be installed from the julia package  manager REPL with","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add NeuralDynamics","category":"page"},{"location":"","page":"Home","title":"Home","text":"From here the package can be loaded by typing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using NeuralDynamics","category":"page"},{"location":"","page":"Home","title":"Home","text":"into the julia REPL.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Tutorial for a basic example of the workflow and features available.","category":"page"},{"location":"#List-of-currently-implemented-models","page":"Home","title":"List of currently implemented models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following models are currently available and can be called using the  associated string in parentheses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"FitzHughNagumo (\"FSH\")\nWilson-Cowan (\"WC\")\nSimple Feed-forward(\"SFF\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Interactive Examples\nWorking examples of analyses with interactivity can be found in the Pluto notebooks found in the notebooks folder.","category":"page"},{"location":"#In-Progress","page":"Home","title":"In Progress","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"generalize simulation function\ngeneralize getJacobianEigenvalues function\nImplement HH and LIF models\nIntroduce higher order RK methods for simulation\nAdd Ising simulation\nAdd Bifurcation Diagrams\nAlways room to refactor","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation produced using Documenter.jl Last updated 2021-08-08","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here I give an example of an analysis workflow showcasing some of the convenience functions built into this package by looking at a Wilson-Cowan network model. ","category":"page"},{"location":"tutorial/#Initialize-model","page":"Tutorial","title":"Initialize model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Begin by loading the pacakge along with Plots so we can visualize our work.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using NeuralDyanmics, Plots","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We will then be able to instantiate our model. Custom models can be built but since the Wilson-Cowan model is built in we can simply call the default parameters and the model equations as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> params = initializeParams(\"WC\")\nDict{Symbol, Float64} with 12 entries:\n    :tauE   => 1.0\n    :wEE    => 9.0\n    :wIE    => 13.0\n    :thetaE => 2.8\n    :wEI    => 4.0\n    :wII    => 11.0\n    :tauI   => 2.0\n    :aE     => 1.2\n    :aI     => 1.0\n    :II     => 0.0\n    :thetaI => 4.0\n    :IE     => 0.0\n\njulia> mdl = modelEquations(\"WC\")\nmodelEquations(\"WC\", (NeuralDynamics.wc_drₑ, NeuralDynamics.wc_drᵢ), (NeuralDynae, NeuralDynamics.wc_iNullcline))","category":"page"},{"location":"tutorial/#Find-nullclines","page":"Tutorial","title":"Find nullclines","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Above I have shown the output to give you some idea of these structures that are used throughout the majority of this package. We may like to begin by exploring our model in the phase plane. The equations for the nullclines can be found in our modelEquations as we can see by typing the following:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> mdl.nullclines\n(NeuralDynamics.wc_eNullcline, NeuralDynamics.wc_iNullcline)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Thus, we can define the space we would like to observe and call the function getNullclines and plot the output to visualize our nullclines in the phase plane.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rₑNull = collect(-0.01:0.001:0.96)\nrᵢNull = collect(-0.01:0.001:0.8)\nncls = getNullclines(rₑNull, rᵢNull, mdl, params)\n\nplot(rₑNull, ncls[1], xlab=\"rₑ\", ylab=\"rᵢ\", label=\"E Nullcline\", linewidth=2, legend=:topleft)\nplot!(ncls[2], rᵢNull, label=\"I Nullcline\", linewidth=2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: nullclines)","category":"page"},{"location":"tutorial/#Find-fixed-points","page":"Tutorial","title":"Find fixed points","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We see that our model has three fixed points so our next step may be to numerically estimate the locations of these fixed points. For this we can call the findfixedpoints function. This function will need to be supplied with some initial guesses which we can visually determine from the previous plot. We will also use the helper function fWC! here and visualize the fixed points on the previous plot.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"fps = findFixedPoints(guesses, fWC!, params)\nfor coord in fps\n\tdispVal = round.(coord, digits=2)\n\tscatter!([coord[1]], [coord[2]], color=:black, markersize=8,\n\t\tlegend=:none)\n\tannotate!([coord[1]], [coord[2]+0.1], text(\"$dispVal\"))\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: fixedPoints)","category":"page"},{"location":"tutorial/#Find-fixed-point-stability-numerically","page":"Tutorial","title":"Find fixed point stability numerically","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now that we have our fixed points we may be interested in which of these fixed points were stable. This can be tested numerically by checking the eigenvalues of the Jacobian matrix describing our system. If any of the real components for a given point are positive then that fixed point is unstable. For this we will use the getJacobianEigenvalues function and check the results.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"getJacobianEigenvalues(fps, params)\n3-element Vector{Any}:\nComplexF64[-0.6233838572258439 - 0.1311095729053099im, -0.6233838572258439 + 0.1311095729053099im]\n[-0.8726689790568727, 1.057207976436168]\n[-1.4219741349895596, -0.95956219494619]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Checking this we see that our second fixpoint is unstable and the other two are stable. ","category":"page"},{"location":"tutorial/#Observe-vector-fields","page":"Tutorial","title":"Observe vector fields","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, or as a complementary approach we may wish to visualize the behavior of the system. One way we may do this is by plotting the vector fields on top of our original plot of the nullclines. First we call the function getVectorFields and we input these results into the convenience plotting function plotVectorFields!. Notice the ! at the end of this function. This means that this function is ment to modify an existing plot and not generate a new plot on its own.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"eiArr = 0:0.05:1\nfields = getVectorFields(eiArr, wc2, params, subdivisions=15)\n\nplot(rₑNull, ncls[1], xlab=\"rₑ\", ylab=\"rᵢ\", label=\"E Nullcline\", \t\t\t\t\t\t\tlinewidth=2, legend=:outertopright)\nplot!(ncls[2], rᵢNull, label=\"I Nullcline\", linewidth=2)\nplotVectorFields!(eiArr, fields, color =:teal, alpha=0.2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: vectorFields)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that we supplied an array that defines the space over which we want to generate our field lines. Further, we supplied the optional argument subdivisions that will define the granularity of the sampling of this space. The default value is 10 which would result in a 10x10 grid of field lines. Here, we generated a 15x15 grid. ","category":"page"},{"location":"tutorial/#Simulate-data","page":"Tutorial","title":"Simulate data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is still difficult to predict the behavior from visualizing the field lines alone. It may be advantageous to pick initial conditions in phase space and simulate the behavior of the system using the function simulate.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"## Simulate with different initial conditions\nrₑ3, rᵢ3 = simulate(0:0.1:50, \"WC\", params, (0.6,0.8))\nrₑ4, rᵢ4 = simulate(0:0.1:50, \"WC\", params, (0.6,0.6))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We can then visualize these simulations by plotting them using the function plotTrajectory!. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"plotTrajectory!(rₑ3, rᵢ3, color=:orange, label=\"Sample trajectory: \\nlow activity\", markersize=10, linewidth=2, markerstrokewidth=0)\nplotTrajectory!(rₑ4, rᵢ4, color=:purple, label=\"Sample trajectory: \\nhigh activity\", markersize=10, linewidth=2, markerstrokewidth=0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: sample simulations)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Interestingly, and perhaps unsurprisingly based on our numerical results we see here that each simulation converges to one of the two stable fixed points we found earlier.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We may wish to sample more of the phase space in our simulations. I will remove the vector fields here for clarity but we can call the function plotTrajectories!. Unlike plotTrajectory the simulation is built into this function. We must simply define a set of coordinates from which to seed these simulations. Here I'll use the vector sampleSpace to define that granularity and will reset the plot to simply show these simulations on top of the nullclines for clarity.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sampleSpace = 0.0:0.2:1\n\nplot(rₑNull, ncls[1], xlab=\"rₑ\", ylab=\"rᵢ\", label=\"E Nullcline\", \t\t\t\t\t\t\tlinewidth=2, legend=:outertopright)\nplot!(ncls[2], rᵢNull, label=\"I Nullcline\", linewidth=2)\nplotTrajectories!(0:0.1:50, sampleSpace, sampleSpace, \"WC\", params, color=:gray, label=\"Sample Trajectories\", alpha=0.5)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: sample simulations2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This further cements the idea that our central fixed point is likely unstable (at least at the granularity we have sampled). We can see that all our simulations converge on either of the two stable fixed points we found earlier.","category":"page"},{"location":"tutorial/#Simulations-in-time-domain","page":"Tutorial","title":"Simulations in time domain","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"While phase space can be informative we lose information about the behavior of our system in time. Here, I will show the same system under a different set of initial conditions in both phase space and in the time domain. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"params = initializeParams(\"WC\";wEE=6.4, wEI=4.8, wIE=6.0, wII=1.2, IE=0.8, tauI=2.0)\n\nncls = getNullclines(rₑNull, rᵢNull, mdl, params)\nfields = getVectorFields(eiArr, mdl, params)\n\nl3 = @layout [a b]\n\npWC3 = plot(rₑNull, ncls[1], xlab=\"rₑ\", ylab=\"rᵢ\", label=\"E Nullcline\", \t\t\t\t\t\t\tlinewidth=2, legend=:none)\nplot!(ncls[2], rᵢNull, label=\"I Nullcline\", linewidth=2)\nplotVectorFields!(eiArr, fields, color =:teal, alpha=0.3)\nplotTrajectories!(0:0.1:100, sampleSpace2, sampleSpace2, \"WC\", params4, color=:gray, label=\"Sample Trajectories\", alpha=0.5)\n\npWC3Activity = plot(0:0.1:100, rₑ8, label=\"E population\", color=:blue, ylim=(0,1))\nplot!(0:0.1:100, rᵢ8, label=\"I population\", color=:red) \n\nplot(pWC3, pWC3Activity, layout=l3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: sample simulations3)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Much of the code above is dedicated to styling the plots you can learn more about this by looking at the documentation for Plots.jl. As you can see however the workflow for analyzing the dynamical systems is relatively simple.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Under these initial conditions we see that our system appears to fall into a stable limit cycle and in the time domain we see tonic spiking activity!","category":"page"},{"location":"tutorial/#Remarks","page":"Tutorial","title":"Remarks","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"I hope this tutorial was clear and please reach out if you have any questions or suggestions. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you would like some more examples there are a number of Pluto notebooks attached to the repository that allow for interactive exploration of this example and others.","category":"page"}]
}
